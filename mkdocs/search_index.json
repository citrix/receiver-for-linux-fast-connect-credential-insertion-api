{
    "docs": [
        {
            "location": "/", 
            "text": "Fast Connect Credential Insertion API for Citrix Receiver for Linux 13.10\n\n\nThe Fast Connect Credential Insertion API provides an interface that supplies user credentials to the Receiver for Linux 13.10 Single Sign-on (SSO) feature. Using this API, Citrix partners can provide authentication and SSO products that use StoreFront to log users on to virtual applications or desktops and then disconnect users from those sessions.\n\n\nThe system requirements and prerequisites for the API are the same as those for Citrix Receiver.", 
            "title": "Home"
        }, 
        {
            "location": "/#fast-connect-credential-insertion-api-for-citrix-receiver-for-linux-1310", 
            "text": "The Fast Connect Credential Insertion API provides an interface that supplies user credentials to the Receiver for Linux 13.10 Single Sign-on (SSO) feature. Using this API, Citrix partners can provide authentication and SSO products that use StoreFront to log users on to virtual applications or desktops and then disconnect users from those sessions.  The system requirements and prerequisites for the API are the same as those for Citrix Receiver.", 
            "title": "Fast Connect Credential Insertion API for Citrix Receiver for Linux 13.10"
        }, 
        {
            "location": "/setting-up-your-environment/", 
            "text": "Setting up your environment\n\n\nTo use the Fast Connect API you must first configure your site appropriately:\n\n\n\n\nIn StoreFront, enable the HTTP Basic authentication method as follows: \n\n\nIf Citrix Receiver for Linux is running, close it.\n\n\nIf the Authentication Manager (AM) daemon is running, terminate it.\n\n\nAdd the following key to the AM configuration file ($ICAROOT/config/AuthManConfig.xml) to allow HTTP Basic authentication, which is needed for SSO:\n\n\n\n\nProtocols\n\n    \nHTTPBasic\n\n        \nEnabled\nTrue\n/Enabled\n\n    \n/HTTPBasic\n\n\n/Protocols\n\n\n\n\n\n\nIf the protocol key is already present and configured with other protocols, add the HTTPBasic sub-key to the Protocols node.\n\n\nNote\n: AM\u2019s configuration file included with Citrix Receiver for Linux 13.10 contains an example of how to enable HTTPBasic support.\n\n\n. Start Citrix Receiver for Linux.\n\n\n. You can now inject a user name and password into the SSO functionality by interacting with the Fast Connect API, using the \nLogonSsoUser()\n function described later in this document.\n\n\n. If you are prompted for an account, specify the URL for your StoreFront Service Site. A StoreFront URL looks like this: \nhttps://SMBSZ-XENAPPS1.xa.local/Citrix/Store/discovery\n\n\n. To get the store accepted, confirm the store\u2019s URL.\n\n\n. If the credentials injected in step 6 are valid for the store you just configured, you will be immediately logged on to your account:\n\n\n\n\nReceiver on the endpoint is now set up for SSO and Fast Connect API use.\n\n\n. If you want to remove the credentials from SSO, use the \nLogoffSsoUser()\n function described in the following section.", 
            "title": "Setting up your environment"
        }, 
        {
            "location": "/setting-up-your-environment/#setting-up-your-environment", 
            "text": "To use the Fast Connect API you must first configure your site appropriately:   In StoreFront, enable the HTTP Basic authentication method as follows:   If Citrix Receiver for Linux is running, close it.  If the Authentication Manager (AM) daemon is running, terminate it.  Add the following key to the AM configuration file ($ICAROOT/config/AuthManConfig.xml) to allow HTTP Basic authentication, which is needed for SSO:   Protocols \n     HTTPBasic \n         Enabled True /Enabled \n     /HTTPBasic  /Protocols   If the protocol key is already present and configured with other protocols, add the HTTPBasic sub-key to the Protocols node.  Note : AM\u2019s configuration file included with Citrix Receiver for Linux 13.10 contains an example of how to enable HTTPBasic support.  . Start Citrix Receiver for Linux.  . You can now inject a user name and password into the SSO functionality by interacting with the Fast Connect API, using the  LogonSsoUser()  function described later in this document.  . If you are prompted for an account, specify the URL for your StoreFront Service Site. A StoreFront URL looks like this:  https://SMBSZ-XENAPPS1.xa.local/Citrix/Store/discovery  . To get the store accepted, confirm the store\u2019s URL.  . If the credentials injected in step 6 are valid for the store you just configured, you will be immediately logged on to your account:   Receiver on the endpoint is now set up for SSO and Fast Connect API use.  . If you want to remove the credentials from SSO, use the  LogoffSsoUser()  function described in the following section.", 
            "title": "Setting up your environment"
        }, 
        {
            "location": "/api-functions/", 
            "text": "API functions\n\n\nThe Credential Insertion SDK is a C/C++ library that must be consumed by external source code. The module name is libCredInject.so.\n\u2028The Credential Insertion API exposes four functions to enable the use of SSO as follows:\n\n\n\n\nLogonSSOUser\n\n\nLogonSSOUserWithPin\n\n\nLogoffSSOUser\n\n\nErrorDescription\n\n\n\n\nThe function is available under the namespace CitrixSSOnSDK.\n\n\nLogonSSOUser\n\n\nLOGONSSOUSER_ERROR_CODE LogonSsoUser (const wchar_t *username,\n                                        const wchar_t *domain,\n                                        const wchar_t *password);\n\n\n\n\n\nThis function is used to provide user credentials to SSO.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nusername\n\n\nThe username\n\n\n\n\n\n\ndomain\n\n\nThe domain\n\n\n\n\n\n\npassword\n\n\nThe password\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_CONTAINER_FULL\n\n\nThe SSO container is full and cannot store more credentials\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nLogonSsoUserWithPin\n\n\nLOGONSSOUSER_ERROR_CODE LogonSsoUserWithPin(const wchar_t *pin)\n\n\n\n\n\nThis function is used to provide smart card user credentials to SSO.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npin\n\n\nThe smart card PIN\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_CONTAINER_FULL\n\n\nThe SSO container is full and cannot store more credentials\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nLogoffSsoUser\n\n\nint LogoffSsoUser()\n\n\n\n\n\nThis function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nLOGONSSOUSER_OK\n\n\nOperation completed\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_PARAMETER\n\n\nInvalid parameter passed to the function\n\n\n\n\n\n\nLOGONSSOUSER_INITIALIZATION_FAILED\n\n\nAn error occurred initializing the SSO client\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO\n\n\nUnable to connect to the SSO service (AM)\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_SEND_REQUEST\n\n\nUnable to send the request to the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE\n\n\nUnable to receive the response from the SSO service\n\n\n\n\n\n\nLOGONSSOUSER_INVALID_REQUEST_TYPE\n\n\nInvalid SSO request type\n\n\n\n\n\n\nLOGONSSOUSER_UNAUTHORIZED\n\n\nTrying to remove a set of credentials that was stored in SSO by AM itself\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_INTERNAL_ERROR\n\n\nAn error has occurred in AM while processing the request\n\n\n\n\n\n\nLOGONSSOUSER_SERVER_IPC_ERROR\n\n\nAn error has occurred during the IPC communication with the server (AM)\n\n\n\n\n\n\n\n\nErrorDescription\n\n\nconst wchar_t *ErrorDescription(LOGONSSOUSER_ERROR_CODE errorCode)\n\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nerrorCode\n\n\nThe error code to get the description of\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReturn value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nThe error description\n\n\nThe error description string, or an \u201cUnknown error\u201d message if the error code is unknown", 
            "title": "API functions"
        }, 
        {
            "location": "/api-functions/#api-functions", 
            "text": "The Credential Insertion SDK is a C/C++ library that must be consumed by external source code. The module name is libCredInject.so.\n\u2028The Credential Insertion API exposes four functions to enable the use of SSO as follows:   LogonSSOUser  LogonSSOUserWithPin  LogoffSSOUser  ErrorDescription   The function is available under the namespace CitrixSSOnSDK.", 
            "title": "API functions"
        }, 
        {
            "location": "/api-functions/#logonssouser", 
            "text": "LOGONSSOUSER_ERROR_CODE LogonSsoUser (const wchar_t *username,\n                                        const wchar_t *domain,\n                                        const wchar_t *password);  This function is used to provide user credentials to SSO.     Parameter  Description      username  The username    domain  The domain    password  The password        Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_CONTAINER_FULL  The SSO container is full and cannot store more credentials    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogonSSOUser"
        }, 
        {
            "location": "/api-functions/#logonssouserwithpin", 
            "text": "LOGONSSOUSER_ERROR_CODE LogonSsoUserWithPin(const wchar_t *pin)  This function is used to provide smart card user credentials to SSO.     Parameter  Description      pin  The smart card PIN        Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_CONTAINER_FULL  The SSO container is full and cannot store more credentials    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogonSsoUserWithPin"
        }, 
        {
            "location": "/api-functions/#logoffssouser", 
            "text": "int LogoffSsoUser()  This function removes the credentials of the current SSO user and restores the previous user\u2019s credentials if available.     Return value  Description      LOGONSSOUSER_OK  Operation completed    LOGONSSOUSER_INVALID_PARAMETER  Invalid parameter passed to the function    LOGONSSOUSER_INITIALIZATION_FAILED  An error occurred initializing the SSO client    LOGONSSOUSER_UNABLE_TO_CONNECT_TO_SSO  Unable to connect to the SSO service (AM)    LOGONSSOUSER_UNABLE_TO_SEND_REQUEST  Unable to send the request to the SSO service    LOGONSSOUSER_UNABLE_TO_RECEIVE_RESPONSE  Unable to receive the response from the SSO service    LOGONSSOUSER_INVALID_REQUEST_TYPE  Invalid SSO request type    LOGONSSOUSER_UNAUTHORIZED  Trying to remove a set of credentials that was stored in SSO by AM itself    LOGONSSOUSER_SERVER_INTERNAL_ERROR  An error has occurred in AM while processing the request    LOGONSSOUSER_SERVER_IPC_ERROR  An error has occurred during the IPC communication with the server (AM)", 
            "title": "LogoffSsoUser"
        }, 
        {
            "location": "/api-functions/#errordescription", 
            "text": "const wchar_t *ErrorDescription(LOGONSSOUSER_ERROR_CODE errorCode)     Parameter  Description      errorCode  The error code to get the description of        Return value  Description      The error description  The error description string, or an \u201cUnknown error\u201d message if the error code is unknown", 
            "title": "ErrorDescription"
        }, 
        {
            "location": "/api-examples/", 
            "text": "API examples\n\n\nThe following are simple examples that show how to consume the Fast Connect API.\n\n\nExample 1: Log on a user\n\n\nThe following code provides user credentials to SSO to log on a user.\n\n\nbool\n \nDoLogonSsoUser\n(\nconst\n \nstd\n::\nwstring\n \nusername\n,\n\n                    \nconst\n \nstd\n::\nwstring\n \ndomain\n,\n\n                    \nconst\n \nstd\n::\nwstring\n \npassword\n)\n\n\n{\n\n    \nif\n \n(username.empty()\n\n            \n||\n \npassword.empty()\n\n            \n||\n \ndomain.empty())\n\n    \n{\n\n        \n//\n \nCredentials\n \nunavailable\n \nor\n \nincomplete.\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nCredentials\n \nare\n \navailable\n,\n \ninject\n \nthem\n \nto\n \nSSO\n.\n\n    \nCitrixSSOnSDK\n::\nLOGONSSOUSER_ERROR_CODE\n \nresult\n \n=\n\n        \nCitrixSSOnSDK\n::\nLogonSsoUser\n(\nusername\n.\nc_str\n(),\n\n                                    \ndomain\n.\nc_str\n(),\n\n                                    \npassword\n.\nc_str\n());\n\n\n    \n//\n \nCheck\n \nwhether\n \nthe\n \ncredential\n \ninjection\n \nwas\n \nsuccessful\n.\n\n    \nif\n \n(\nresult\n \n!=\n \nCitrixSSOnSDK\n::\nLOGONSSOUSER_OK\n)\n    \n{\n\n        \n//\n \nGet\n \nthe\n \nresult\n \ndescription.\n\n        \nconst\n \nwchar_t\n \n*result_description\n \n=\n \nCitrixSSOnSDK\n:\n:\nErrorDescription\n(\nresult\n);\n\n\n        \n//\n \nReport\n \nthe\n \nerror.\n\n        \nwprintf(L\nLogonSsoUser()\n \nfailed\n:\n \n%\nd\n \n%\nls\n\\\nn\n,\n \nresult\n,\n \nresult_description\n);\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nSuccess\n.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\nExample 2: Log on a user with a smart card\n\n\nThe following code provides user credentials to SSO to log on a user with a smart card.\n\n\nbool\n \nDoLogonSsoUserWithPin\n(\nconst\n \nstd\n::\nwstring\n \npin\n)\n\n\n{\n\n    \nif\n \n(pin.empty())\n\n    \n{\n\n        \n//\n \nPIN\n \nunavailable.\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nPIN\n \nis\n \navailable\n,\n \ninject\n \nit\n \nto\n \nSSO\n.\n\n    \nCitrixSSOnSDK\n::\nLOGONSSOUSER_ERROR_CODE\n \nresult\n \n=\n\n        \nCitrixSSOnSDK\n::\nLogonSsoUserWithPin\n(\npin\n.\nc_str\n());\n\n\n    \n//\n \nCheck\n \nwhether\n \nthe\n \nPIN\n \ninjection\n \nwas\n \nsuccessful\n.\n\n    \nif\n \n(\nresult\n \n!=\n \nCitrixSSOnSDK\n::\nLOGONSSOUSER_OK\n)\n\n    \n{\n\n        \n//\n \nGet\n \nthe\n \nresult\n \ndescription.\n\n        \nconst\n \nwchar_t\n \n*result_description\n \n=\n \nCitrixSSOnSDK\n:\n:\nErrorDescription\n(\nresult\n);\n\n\n        \n//\n \nReport\n \nthe\n \nerror.\n\n        \nwprintf(L\nLogonSsoUserWithPin()\n \nfailed\n:\n \n%\nd\n \n%\nls\n\\\nn\n,\n \nresult\n,\n \nresult_description\n);\n\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n    \n//\n \nSuccess\n.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\n\nExample 3: Log off a user\n\n\nThis function performs a logoff from a SSO perspective, removing the user\u2019s credentials from the system for the purpose of future SSO-based authorization. Existing authorized sessions can still be used. If the previous user was not logged off, that user\u2019s credentials are restored (see example 4).\n\n\nvoid DoLogoffSsoUser()\n{\n    if (CitrixSSOnSDK::LogoffSsoUser() == LOGONSSOUSER_OK)\n        printf(\n\\nUser logged off\\n\n);\n    else\n        printf(\n\\nError logging off user\\n\n);\n}\n\n\n\n\n\nExample 4: Managing an exclusive endpoint\n\n\nIf the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon results in clearing the SSO credentials and requires authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CredInject:\n\n\n\n\nA kiosk is auto-logged on with a default/generic user (Controller calls LogonSsoUser())\n\n\nThe kiosk is then available with generic credentials for customer use.\n\n\nSales Rep A logs on with his own credentials:\n\n\nController calls LogonSsoUser().\n\n\nController disconnects generic user\u2019s sessions.\n\n\nController roams existing sessions for Sales Rep A.\n\n\n\n\n\n\nThe kiosk can launch new sessions using Sales Rep A\u2019s credentials.\n\n\nSales Rep A logs off:\n\n\nController calls LogoffSsoUser(), removing Sales Rep A\u2019s credentials and restoring the generic user.\n\n\nController restores generic user\u2019s sessions.\n\n\n\n\n\n\nThe kiosk is back to its initial state and is available for use with generic credentials.\n\n\nSales Rep B logs on (repeat Steps 3-5 for Sales Rep B).\n\n\nThe kiosk is back to its initial state.\n\n\n\n\nThis scenario can be repeated infinitely.\n\n\nExample 5: Managing user restore and shared endpoints\n\n\nIf the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon results in clearing the SSO credentials and requires authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CredInject:\n\n\n\n\nA nurse logs on normally and launches sessions. (Controller calls LogonSsoUser()).\n\n\nA doctor \u201ctaps in\u201d:\n\n\nController executes LogonSsoUser() with the doctor\u2019s credentials.\n\n\nController does not log off the nurse or disconnect sessions.\n\n\nController causes any existing doctor\u2019s sessions to be roamed to this endpoint.\n\n\n\n\n\n\nAt this point both the nurse\u2019s and the doctor\u2019s sessions are active. New sessions will be launched using the doctor\u2019s credentials.\n\n\nThe doctor \u201ctaps out\u201d:\n\n\nController calls LogoffSsoUser(), removing the doctor\u2019s credentials and restoring the nurse\u2019s.\n\n\nController disconnects the doctor\u2019s sessions.\n\n\nThe nurse\u2019s sessions are still active.\n\n\n\n\n\n\nThe nurse resumes as at Step 1.", 
            "title": "API examples"
        }, 
        {
            "location": "/api-examples/#api-examples", 
            "text": "The following are simple examples that show how to consume the Fast Connect API.", 
            "title": "API examples"
        }, 
        {
            "location": "/api-examples/#example-1-log-on-a-user", 
            "text": "The following code provides user credentials to SSO to log on a user.  bool   DoLogonSsoUser ( const   std :: wstring   username , \n                     const   std :: wstring   domain , \n                     const   std :: wstring   password )  { \n     if   (username.empty() \n             ||   password.empty() \n             ||   domain.empty()) \n     { \n         //   Credentials   unavailable   or   incomplete. \n         return   false ; \n     } \n\n     //   Credentials   are   available ,   inject   them   to   SSO . \n     CitrixSSOnSDK :: LOGONSSOUSER_ERROR_CODE   result   = \n         CitrixSSOnSDK :: LogonSsoUser ( username . c_str (), \n                                     domain . c_str (), \n                                     password . c_str ()); \n\n     //   Check   whether   the   credential   injection   was   successful . \n     if   ( result   !=   CitrixSSOnSDK :: LOGONSSOUSER_OK )      { \n         //   Get   the   result   description. \n         const   wchar_t   *result_description   =   CitrixSSOnSDK : : ErrorDescription ( result ); \n\n         //   Report   the   error. \n         wprintf(L LogonSsoUser()   failed :   % d   % ls \\ n ,   result ,   result_description ); \n\n         return   false ; \n     } \n\n     //   Success . \n     return   true ;  }", 
            "title": "Example 1: Log on a user"
        }, 
        {
            "location": "/api-examples/#example-2-log-on-a-user-with-a-smart-card", 
            "text": "The following code provides user credentials to SSO to log on a user with a smart card.  bool   DoLogonSsoUserWithPin ( const   std :: wstring   pin )  { \n     if   (pin.empty()) \n     { \n         //   PIN   unavailable. \n         return   false ; \n     } \n\n     //   PIN   is   available ,   inject   it   to   SSO . \n     CitrixSSOnSDK :: LOGONSSOUSER_ERROR_CODE   result   = \n         CitrixSSOnSDK :: LogonSsoUserWithPin ( pin . c_str ()); \n\n     //   Check   whether   the   PIN   injection   was   successful . \n     if   ( result   !=   CitrixSSOnSDK :: LOGONSSOUSER_OK ) \n     { \n         //   Get   the   result   description. \n         const   wchar_t   *result_description   =   CitrixSSOnSDK : : ErrorDescription ( result ); \n\n         //   Report   the   error. \n         wprintf(L LogonSsoUserWithPin()   failed :   % d   % ls \\ n ,   result ,   result_description ); \n\n         return   false ; \n     } \n\n     //   Success . \n     return   true ;  }", 
            "title": "Example 2: Log on a user with a smart card"
        }, 
        {
            "location": "/api-examples/#example-3-log-off-a-user", 
            "text": "This function performs a logoff from a SSO perspective, removing the user\u2019s credentials from the system for the purpose of future SSO-based authorization. Existing authorized sessions can still be used. If the previous user was not logged off, that user\u2019s credentials are restored (see example 4).  void DoLogoffSsoUser()\n{\n    if (CitrixSSOnSDK::LogoffSsoUser() == LOGONSSOUSER_OK)\n        printf( \\nUser logged off\\n );\n    else\n        printf( \\nError logging off user\\n );\n}", 
            "title": "Example 3: Log off a user"
        }, 
        {
            "location": "/api-examples/#example-4-managing-an-exclusive-endpoint", 
            "text": "If the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon results in clearing the SSO credentials and requires authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CredInject:   A kiosk is auto-logged on with a default/generic user (Controller calls LogonSsoUser())  The kiosk is then available with generic credentials for customer use.  Sales Rep A logs on with his own credentials:  Controller calls LogonSsoUser().  Controller disconnects generic user\u2019s sessions.  Controller roams existing sessions for Sales Rep A.    The kiosk can launch new sessions using Sales Rep A\u2019s credentials.  Sales Rep A logs off:  Controller calls LogoffSsoUser(), removing Sales Rep A\u2019s credentials and restoring the generic user.  Controller restores generic user\u2019s sessions.    The kiosk is back to its initial state and is available for use with generic credentials.  Sales Rep B logs on (repeat Steps 3-5 for Sales Rep B).  The kiosk is back to its initial state.   This scenario can be repeated infinitely.", 
            "title": "Example 4: Managing an exclusive endpoint"
        }, 
        {
            "location": "/api-examples/#example-5-managing-user-restore-and-shared-endpoints", 
            "text": "If the current user is not logged off and a new user is logged on, the previous user\u2019s credentials are saved by the system to be restored when the current user logs off. Only a single level of restore is supported. Logging off a second time without an intervening logon results in clearing the SSO credentials and requires authentication before launching new sessions. This supports the following scenario using Controller, which is a custom application using CredInject:   A nurse logs on normally and launches sessions. (Controller calls LogonSsoUser()).  A doctor \u201ctaps in\u201d:  Controller executes LogonSsoUser() with the doctor\u2019s credentials.  Controller does not log off the nurse or disconnect sessions.  Controller causes any existing doctor\u2019s sessions to be roamed to this endpoint.    At this point both the nurse\u2019s and the doctor\u2019s sessions are active. New sessions will be launched using the doctor\u2019s credentials.  The doctor \u201ctaps out\u201d:  Controller calls LogoffSsoUser(), removing the doctor\u2019s credentials and restoring the nurse\u2019s.  Controller disconnects the doctor\u2019s sessions.  The nurse\u2019s sessions are still active.    The nurse resumes as at Step 1.", 
            "title": "Example 5: Managing user restore and shared endpoints"
        }, 
        {
            "location": "/credential-comparison-rules/", 
            "text": "Credential comparison rules\n\n\nAfter a set of credentials is inserted, the SSO implementation in AM allows for a second set of credentials to be inserted on top of the first one, provided that the second credentials are different. That means that at most two separate sets of credentials can be stored at the same time (that is, only a single level of restore is supported). The credentials are cached in SSO in a stack fashion, with only the topmost set of credentials accessible for authentication.\n\n\nWhen inserting a set of credentials into SSO, it is compared to those already available in the container (if any).\n\u2028If the comparison is positive, the new credentials are ignored and not cached.\n\u2028If the comparison is negative, the new credentials are stored on top of the currently stored credentials (if the second slot is available).\n\n\nThe rule enforced to compare domain credentials is as follows: Two sets of domain credentials are considered matching if username and domain are equal (the password is ignored in the comparison).\n\n\nThe rule enforced to compare smart card credentials is as follows: PINs never match (they are always considered different because they might be associated with different smart cards).\n\n\nDomain credentials examples\n\n\n\n\nusernameA/domainA/passwordA == usernameA/domainA/passwordA\n\u2028\nCredentials match: all three fields match.\n\n\nusernameA/domainA/passwordA != usernameB/domainA/passwordA\n\u2028\nCredentials do not match: the username is different.\n\n\nusernameA/domainA/passwordA != usernameA/domainB/passwordA\n\u2028\nCredentials do not match: the domain is different.\n\n\nusernameA/domainA/passwordA == usernameA/domainA/passwordB\n\u2028\nCredentials match: only the password is different.\n\n\n\n\nSmart card credential examples\n\n\n\n\nPIN 1234 != PIN 5678\n\u2028\nPINs are different.\n\n\nPIN 1234 != PIN 1234\n\u2028\nPINs are considered different even if they are actually identical.", 
            "title": "Credential comparison rules"
        }, 
        {
            "location": "/credential-comparison-rules/#credential-comparison-rules", 
            "text": "After a set of credentials is inserted, the SSO implementation in AM allows for a second set of credentials to be inserted on top of the first one, provided that the second credentials are different. That means that at most two separate sets of credentials can be stored at the same time (that is, only a single level of restore is supported). The credentials are cached in SSO in a stack fashion, with only the topmost set of credentials accessible for authentication.  When inserting a set of credentials into SSO, it is compared to those already available in the container (if any).\n\u2028If the comparison is positive, the new credentials are ignored and not cached.\n\u2028If the comparison is negative, the new credentials are stored on top of the currently stored credentials (if the second slot is available).  The rule enforced to compare domain credentials is as follows: Two sets of domain credentials are considered matching if username and domain are equal (the password is ignored in the comparison).  The rule enforced to compare smart card credentials is as follows: PINs never match (they are always considered different because they might be associated with different smart cards).", 
            "title": "Credential comparison rules"
        }, 
        {
            "location": "/credential-comparison-rules/#domain-credentials-examples", 
            "text": "usernameA/domainA/passwordA == usernameA/domainA/passwordA \u2028 Credentials match: all three fields match.  usernameA/domainA/passwordA != usernameB/domainA/passwordA \u2028 Credentials do not match: the username is different.  usernameA/domainA/passwordA != usernameA/domainB/passwordA \u2028 Credentials do not match: the domain is different.  usernameA/domainA/passwordA == usernameA/domainA/passwordB \u2028 Credentials match: only the password is different.", 
            "title": "Domain credentials examples"
        }, 
        {
            "location": "/credential-comparison-rules/#smart-card-credential-examples", 
            "text": "PIN 1234 != PIN 5678 \u2028 PINs are different.  PIN 1234 != PIN 1234 \u2028 PINs are considered different even if they are actually identical.", 
            "title": "Smart card credential examples"
        }
    ]
}